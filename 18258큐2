#include <stdio.h>
#include <stdlib.h>
#include <string.h>
# define _CRT_SECURE_NO_WARNINGS

typedef struct Queue {
	int data[2000000];
	int front, rear;
}Queue;

Queue q;


void init(Queue *q) {
	q->front = 0;
	q->rear = 0;
}

void push(Queue *q, int x) {
	q->data[++(q->rear)] = x;
}
int  empty(Queue *q) {
	if (q->front == q->rear)
		return 1;
	return 0;
}
int  pop(Queue *q) {
	if (empty(q)) 
		return -1;
	return q->data[++(q->front)];	//front에는 아무것도 없어서
}

int  size(Queue *q) {
	return q->rear - q->front;
}



int  front(Queue *q) {
	if (empty(q)) return -1;	//여기서는 &q를 쓰면 Queue의 주소의 주소겠지
	return q->data[q->front];
}

int  back(Queue *q) {
	if (empty(q)) return -1;
	return q->data[q->rear+1];
}

int main(void)
{
	//Queue *q;		초기화되지 않은 q 지역 변수를 사용했습니다.
	
	init(&q);
	int N;
	//char S[10];	메모리 아끼려고 여기에 선언했다가 pushy이런식으로 된다
	
	scanf_s("%d", &N);

	while (N--) { //N번
		char S[10] = {0,};
		scanf_s("%s", &S, 10);

		if (!strcmp(S, "push")) {
			int x;
			scanf_s("%d", &x);
			push(&q, x);
		}
		else if (!strcmp(S, "pop")) {
			printf("%d\n", pop(&q));
		}
		else if (!strcmp(S, "size")) {
			printf("%d\n", size(&q));
		}
		else if (!strcmp(S, "empty")) {
			printf("%d\n", empty(&q));
		}
		else if (!strcmp(S, "front")) {
			printf("%d\n", front(&q));
		}
		else if (!strcmp(S, "back")) {
			printf("%d\n", back(&q));
		}
	}
	return 0;
}
